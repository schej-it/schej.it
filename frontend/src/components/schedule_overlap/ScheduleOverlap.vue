<template>
  <span>
    <div class="tw-m-4 tw-select-none" style="-webkit-touch-callout: none">
      <div class="tw-flex tw-flex-wrap sm:tw-flex-nowrap">
        <div class="tw-flex tw-grow">
          <!-- Times -->
          <div class="tw-w-8 tw-flex-none sm:tw-w-12">
            <div
              :class="calendarOnly ? 'tw-invisible' : 'tw-visible'"
              class="tw-sticky tw-top-14 tw-z-10 -tw-ml-3 tw-mb-3 tw-h-11 tw-bg-white sm:tw-top-16 sm:tw-ml-0"
            >
              <div
                :class="hasPrevPage ? 'tw-visible' : 'tw-invisible'"
                class="tw-sticky tw-top-14 tw-ml-0.5 tw-self-start tw-pt-1.5 sm:tw-top-16 sm:-tw-ml-2"
              >
                <v-btn class="tw-border-gray" outlined icon @click="prevPage"
                  ><v-icon>mdi-chevron-left</v-icon></v-btn
                >
              </div>
            </div>

            <div class="-tw-ml-3 -tw-mt-[8px] sm:tw-ml-0">
              <div
                v-for="(time, i) in times"
                :key="i"
                class="tw-h-4 tw-pr-1 tw-text-right tw-text-xs tw-font-light tw-uppercase sm:tw-pr-2"
              >
                {{ time.text }}
              </div>
            </div>
          </div>

          <!-- Middle section -->
          <div class="tw-grow">
            <div
              ref="calendar"
              @scroll="onCalendarScroll"
              class="tw-relative tw-flex tw-flex-col"
            >
              <!-- Days -->
              <div
                :class="
                  sampleCalendarEventsByDay ? undefined : 'tw-sticky tw-top-14'
                "
                class="tw-z-10 tw-flex tw-h-14 tw-items-center tw-bg-white sm:tw-top-16"
              >
                <div
                  v-for="(day, i) in days"
                  :key="i"
                  class="tw-flex-1 tw-bg-white"
                >
                  <div class="tw-text-center">
                    <div
                      v-if="isSpecificDates || isGroup"
                      class="tw-text-[12px] tw-font-light tw-capitalize tw-text-very-dark-gray sm:tw-text-xs"
                    >
                      {{ day.dateString }}
                    </div>
                    <div class="tw-text-base tw-capitalize sm:tw-text-lg">
                      {{ day.dayText }}
                    </div>
                  </div>
                </div>
              </div>

              <!-- Calendar -->
              <div class="tw-flex tw-flex-col">
                <div class="tw-flex-1">
                  <div
                    id="times"
                    data-long-press-delay="500"
                    class="tw-relative tw-flex"
                    @mouseleave="resetCurTimeslot"
                  >
                    <!-- Loader -->
                    <div
                      v-if="showLoader"
                      class="tw-absolute tw-z-10 tw-grid tw-h-full tw-w-full tw-place-content-center"
                    >
                      <v-progress-circular
                        class="tw-text-green"
                        indeterminate
                      />
                    </div>

                    <div
                      v-for="(day, d) in days"
                      :key="d"
                      class="tw-relative tw-flex-1"
                      :class="
                        ((isGroup && loadingCalendarEvents) ||
                          loadingResponses.loading) &&
                        'tw-opacity-50'
                      "
                    >
                      <!-- Timeslots -->
                      <div
                        v-for="(time, t) in times"
                        :key="t"
                        class="tw-w-full"
                      >
                        <div
                          class="timeslot tw-h-4 tw-border-r tw-border-[#DDDDDD99]"
                          :class="timeslotClassStyle(day, time, d, t).class"
                          :style="timeslotClassStyle(day, time, d, t).style"
                          v-on="timeslotVon(d, t)"
                        ></div>
                      </div>

                      <!-- Calendar events -->
                      <div
                        v-if="
                          !loadingCalendarEvents &&
                          (editing ||
                            alwaysShowCalendarEvents ||
                            showCalendarEvents)
                        "
                      >
                        <transition
                          :name="isGroup ? '' : 'fade-transition'"
                          v-for="event in calendarEventsByDay[
                            d + page * maxDaysPerPage
                          ]"
                          :key="event.id"
                          appear
                        >
                          <div
                            class="tw-absolute tw-w-full tw-select-none tw-p-px"
                            :style="{
                              top: `calc(${event.hoursOffset} * 4 * 1rem)`,
                              height: `calc(${event.hoursLength} * 4 * 1rem)`,
                            }"
                            style="pointer-events: none"
                          >
                            <div
                              class="tw-h-full tw-w-full tw-overflow-hidden tw-text-ellipsis tw-rounded tw-border tw-border-solid tw-p-1 tw-text-xs"
                              :class="
                                event.free
                                  ? isGroup && !editing
                                    ? 'tw-border-white tw-bg-light-blue tw-opacity-50'
                                    : 'tw-border-dashed tw-border-blue'
                                  : isGroup && !editing
                                  ? 'tw-border-white tw-bg-light-blue'
                                  : 'tw-border-blue'
                              "
                            >
                              <div
                                :class="`tw-text-${
                                  isGroup && state !== states.EDIT_AVAILABILITY
                                    ? 'white'
                                    : noEventNames
                                    ? 'dark-gray'
                                    : 'blue'
                                }`"
                                class="ph-no-capture tw-font-medium"
                              >
                                {{ noEventNames ? "BUSY" : event.summary }}
                              </div>
                            </div>
                          </div>
                        </transition>
                      </div>

                      <!-- Scheduled event -->
                      <div v-if="state === states.SCHEDULE_EVENT">
                        <div
                          v-if="
                            (dragStart && dragStart.dayIndex === d) ||
                            (!dragStart &&
                              curScheduledEvent &&
                              curScheduledEvent.dayIndex === d)
                          "
                          class="tw-absolute tw-w-full tw-select-none tw-p-px"
                          :style="scheduledEventStyle"
                          style="pointer-events: none"
                        >
                          <div
                            class="tw-h-full tw-w-full tw-overflow-hidden tw-text-ellipsis tw-rounded tw-border tw-border-solid tw-border-blue tw-bg-blue tw-p-px tw-text-xs"
                          >
                            <div class="tw-font-medium tw-text-white">
                              {{ event.name }}
                            </div>
                          </div>
                        </div>
                      </div>
                    </div>
                  </div>
                </div>
              </div>

              <ZigZag
                v-if="hasPrevPage"
                left
                class="tw-absolute tw-left-0 tw-top-0 tw-h-full tw-w-3"
              />
              <ZigZag
                v-if="hasNextPage"
                right
                class="tw-absolute tw-right-0 tw-top-0 tw-h-full tw-w-3"
              />
            </div>

            <!-- Hint text (desktop) -->
            <v-expand-transition>
              <div
                v-if="!isPhone && showHintText && hintText != '' && !hintClosed"
                class="tw-sticky tw-bottom-4 tw-z-10 tw-flex"
              >
                <div
                  class="tw-mt-2 tw-flex tw-w-full tw-items-center tw-justify-between tw-gap-1 tw-rounded-md tw-bg-off-white tw-p-2 tw-px-[7px] tw-text-sm tw-text-dark-gray"
                >
                  <div class="tw-flex tw-items-center tw-gap-1">
                    <v-icon small>mdi-information-outline</v-icon>
                    {{ hintText }}
                  </div>
                  <v-icon small @click="closeHint">mdi-close</v-icon>
                </div>
              </div></v-expand-transition
            >

            <ToolRow
              v-if="!calendarOnly && !isPhone"
              :state="state"
              :states="states"
              :cur-timezone.sync="curTimezone"
              :show-best-times.sync="showBestTimes"
              :cur-scheduled-event="curScheduledEvent"
              :isGroup="isGroup"
              :is-weekly="isWeekly"
              :calendar-permission-granted="calendarPermissionGranted"
              :week-offset="weekOffset"
              :num-responses="respondents.length"
              :allow-schedule-event="allowScheduleEvent"
              @update:weekOffset="(val) => $emit('update:weekOffset', val)"
              @onShowBestTimesChange="onShowBestTimesChange"
              @scheduleEvent="scheduleEvent"
              @cancelScheduleEvent="cancelScheduleEvent"
              @confirmScheduleEvent="confirmScheduleEvent"
            />
          </div>

          <div
            :class="calendarOnly ? 'tw-invisible' : 'tw-visible'"
            class="tw-sticky tw-top-14 tw-z-10 tw-mb-4 tw-h-11 tw-bg-white sm:tw-top-16"
          >
            <div
              :class="hasNextPage ? 'tw-visible' : 'tw-invisible'"
              class="tw-sticky tw-top-14 -tw-mr-2 tw-self-start tw-pt-1.5 sm:tw-top-16"
            >
              <v-btn class="tw-border-gray" outlined icon @click="nextPage"
                ><v-icon>mdi-chevron-right</v-icon></v-btn
              >
            </div>
          </div>
        </div>

        <div class="break" v-if="isPhone"></div>

        <!-- Respondents -->
        <div
          v-if="!calendarOnly"
          class="tw-w-full tw-py-4 sm:tw-sticky sm:tw-top-16 sm:tw-w-52 sm:tw-flex-none sm:tw-self-start sm:tw-py-0 sm:tw-pl-0 sm:tw-pr-0 sm:tw-pt-12"
        >
          <div
            class="tw-flex tw-flex-col tw-gap-2"
            v-if="state == states.EDIT_AVAILABILITY"
          >
            <CalendarAccounts
              v-if="calendarPermissionGranted"
              :toggleState="true"
              :eventId="event._id"
              :calendar-events-map="calendarEventsMap"
              :syncWithBackend="!isGroup"
              :allowAddCalendarAccount="!isGroup"
              @toggleCalendarAccount="toggleCalendarAccount"
              @toggleSubCalendarAccount="toggleSubCalendarAccount"
              :initialCalendarAccountsData="
                isGroup ? sharedCalendarAccounts : authUser.calendarAccounts
              "
            ></CalendarAccounts>
            <div v-if="userHasResponded || curGuestId">
              <div class="tw-mb-1 tw-font-medium">Options</div>
              <v-dialog
                v-model="deleteAvailabilityDialog"
                width="500"
                persistent
              >
                <template v-slot:activator="{ on, attrs }">
                  <span
                    v-bind="attrs"
                    v-on="on"
                    class="tw-cursor-pointer tw-text-sm tw-text-red tw-underline"
                  >
                    {{ !isGroup ? "Delete availability" : "Leave group" }}
                  </span>
                </template>

                <v-card>
                  <v-card-title>Are you sure?</v-card-title>
                  <v-card-text class="tw-text-sm tw-text-dark-gray"
                    >Are you sure you want to
                    {{
                      !isGroup
                        ? "delete your availability from this event?"
                        : "leave this group?"
                    }}</v-card-text
                  >
                  <v-card-actions>
                    <v-spacer />
                    <v-btn text @click="deleteAvailabilityDialog = false"
                      >Cancel</v-btn
                    >
                    <v-btn
                      text
                      color="error"
                      @click="
                        $emit('deleteAvailability')
                        deleteAvailabilityDialog = false
                      "
                      >{{ !isGroup ? "Delete" : "Leave" }}</v-btn
                    >
                  </v-card-actions>
                </v-card>
              </v-dialog>
            </div>
          </div>
          <template v-else>
            <v-expand-transition>
              <div
                v-if="delayedShowStickyRespondents"
                class="tw-fixed tw-bottom-16 tw-left-0 tw-z-10 tw-w-full tw-bg-white"
              >
                <RespondentsList
                  class="tw-mx-4 tw-mt-4"
                  :max-height="100"
                  :eventId="event._id"
                  :curRespondent="curRespondent"
                  :curRespondents="curRespondents"
                  :curTimeslot="curTimeslot"
                  :curTimeslotAvailability="curTimeslotAvailability"
                  :respondents="respondents"
                  :isOwner="isOwner"
                  :isGroup="isGroup"
                  :attendees="event.attendees"
                  :showCalendarEvents.sync="showCalendarEvents"
                  @mouseOverRespondent="mouseOverRespondent"
                  @mouseLeaveRespondent="mouseLeaveRespondent"
                  @clickRespondent="clickRespondent"
                  @editGuestAvailability="editGuestAvailability"
                  @refreshEvent="refreshEvent"
                />
              </div>
            </v-expand-transition>
            <div ref="beforeRespondentsList"></div>
            <RespondentsList
              :eventId="event._id"
              :curRespondent="curRespondent"
              :curRespondents="curRespondents"
              :curTimeslot="curTimeslot"
              :curTimeslotAvailability="curTimeslotAvailability"
              :respondents="respondents"
              :isOwner="isOwner"
              :isGroup="isGroup"
              :attendees="event.attendees"
              :showCalendarEvents.sync="showCalendarEvents"
              @mouseOverRespondent="mouseOverRespondent"
              @mouseLeaveRespondent="mouseLeaveRespondent"
              @clickRespondent="clickRespondent"
              @editGuestAvailability="editGuestAvailability"
              @refreshEvent="refreshEvent"
            />
          </template>
          <div ref="afterRespondentsList"></div>
        </div>
      </div>

      <ToolRow
        v-if="!calendarOnly && isPhone"
        :state="state"
        :states="states"
        :cur-timezone.sync="curTimezone"
        :show-best-times.sync="showBestTimes"
        :cur-scheduled-event="curScheduledEvent"
        :isGroup="isGroup"
        :is-weekly="isWeekly"
        :calendar-permission-granted="calendarPermissionGranted"
        :week-offset="weekOffset"
        :num-responses="respondents.length"
        :mobile-num-days.sync="mobileNumDays"
        :allow-schedule-event="allowScheduleEvent"
        @update:weekOffset="(val) => $emit('update:weekOffset', val)"
        @onShowBestTimesChange="onShowBestTimesChange"
        @scheduleEvent="scheduleEvent"
        @cancelScheduleEvent="cancelScheduleEvent"
        @confirmScheduleEvent="confirmScheduleEvent"
      />
    </div>
  </span>
</template>

<style scoped>
.animate-bg-color {
  transition: background-color 0.25s ease-in-out;
}

.break {
  flex-basis: 100%;
  height: 0;
}
</style>

<style>
/* Make timezone select element the same width as content */
#timezone-select {
  width: 5px;
}
</style>

<script>
import {
  timeNumToTimeText,
  dateCompare,
  getDateHoursOffset,
  post,
  isBetween,
  clamp,
  isPhone,
  utcTimeToLocalTime,
  splitCalendarEventsByDay,
  dateToDowDate,
  _delete,
  get,
  getDateDayOffset,
  isDateBetween,
  generateEnabledCalendarsPayload,
  isTouchEnabled,
} from "@/utils"
import { eventTypes } from "@/constants"
import { mapMutations, mapActions, mapState } from "vuex"
import UserAvatarContent from "@/components/UserAvatarContent.vue"
import CalendarAccounts from "@/components/settings/CalendarAccounts.vue"
import ZigZag from "./ZigZag.vue"
import ConfirmDetailsDialog from "./ConfirmDetailsDialog.vue"
import ToolRow from "./ToolRow.vue"
import RespondentsList from "./RespondentsList.vue"

import dayjs from "dayjs"
import utcPlugin from "dayjs/plugin/utc"
import timezonePlugin from "dayjs/plugin/timezone"
dayjs.extend(utcPlugin)
dayjs.extend(timezonePlugin)

export default {
  name: "ScheduleOverlap",
  props: {
    event: { type: Object, required: true },

    loadingCalendarEvents: { type: Boolean, default: false }, // Whether we are currently loading the calendar events
    calendarEventsMap: { type: Object, default: () => {} }, // Object of different users' calendar events
    sampleCalendarEventsByDay: { type: Array, required: false }, // Sample calendar events to use for example calendars
    calendarPermissionGranted: { type: Boolean, default: false }, // Whether user has granted google calendar permissions

    weekOffset: { type: Number, default: 0 }, // Week offset used for displaying calendar events on weekly schejs

    alwaysShowCalendarEvents: { type: Boolean, default: false }, // Whether to show calendar events all the time
    noEventNames: { type: Boolean, default: false }, // Whether to show "busy" instead of the event name
    calendarOnly: { type: Boolean, default: false }, // Whether to only show calendar and not respondents or any other controls
    interactable: { type: Boolean, default: true }, // Whether to allow user to interact with component
    showSnackbar: { type: Boolean, default: true }, // Whether to show snackbar when availability is automatically filled in
    animateTimeslotAlways: { type: Boolean, default: false }, // Whether to animate timeslots all the time
    showHintText: { type: Boolean, default: true }, // Whether to show the hint text telling user what to do

    curGuestId: { type: String, default: "" }, // Id of the current guest being edited

    initialTimezone: { type: Object, default: () => ({}) },

    // Availability Groups
    calendarAvailabilities: { type: Object, default: () => ({}) },
  },
  data() {
    return {
      states: {
        HEATMAP: "heatmap", // Display heatmap of availabilities
        SINGLE_AVAILABILITY: "single_availability", // Show one person's availability
        SUBSET_AVAILABILITY: "subset_availability", // Show availability for a subset of people
        BEST_TIMES: "best_times", // Show only the times that work for most people
        EDIT_AVAILABILITY: "edit_availability", // Edit current user's availability
        SCHEDULE_EVENT: "schedule_event", // Schedule event on gcal
      },
      state: "best_times",

      availability: new Set(), // The current user's availability
      availabilityAnimTimeouts: [], // Timeouts for availability animation
      availabilityAnimEnabled: false, // Whether to animate timeslots changing colors
      maxAnimTime: 1200, // Max amount of time for availability animation
      unsavedChanges: false, // If there are unsaved availability changes
      curTimeslot: { dayIndex: -1, timeIndex: -1 }, // The currently highlighted timeslot
      curTimeslotAvailability: {}, // The users available for the current timeslot
      curRespondent: "", // Id of the active respondent (set on hover)
      curRespondents: [], // Id of currently selected respondents (set on click)
      sharedCalendarAccounts: {}, // The user's calendar accounts for changing calendar options for groups
      fetchedResponses: {}, // Responses fetched from the server for the dates currently shown
      loadingResponses: { loading: false, lastFetched: new Date().getTime() }, // Whether we're currently fetching the responses
      responsesFormatted: new Map(), // Map where date/time is mapped to the people that are available then

      /* Variables for drag stuff */
      DRAG_TYPES: {
        ADD: "add",
        REMOVE: "remove",
      },
      timeslot: {
        width: 0,
        height: 0,
      },
      dragging: false,
      dragType: "add",
      dragStart: null,
      dragCur: null,

      /* Variables for options */
      curTimezone: this.initialTimezone,
      curScheduledEvent: null, // The scheduled event represented in the form {hoursOffset, hoursLength, dayIndex}
      showBestTimes: localStorage["showBestTimes"] == "true",
      deleteAvailabilityDialog: false,
      showCalendarEvents: false,

      /* Variables for scrolling */
      calendarScrollLeft: 0, // The current scroll position of the calendar
      calendarMaxScroll: 0, // The maximum scroll amount of the calendar, scrolling to this point means we have scrolled to the end
      scrolledToRespondents: false, // whether we have scrolled to the respondents section
      delayedShowStickyRespondents: false, // showStickyRespondents variable but changes 100ms after the actual variable changes (to add some delay)
      delayedShowStickyRespondentsTimeout: null, // Timeout that sets delayedShowStickyRespondents

      /* Variables for pagination */
      page: 0,
      mobileNumDays: localStorage["mobileNumDays"]
        ? parseInt(localStorage["mobileNumDays"])
        : 3, // The number of days to show at a time on mobile
      pageHasChanged: false,

      hasRefreshedAuthUser: false,

      /* Variables for hint */
      hintState: true,

      /** Groups */
      manualAvailability: {},
    }
  },
  computed: {
    ...mapState(["authUser"]),
    /** Only allow scheduling when a curScheduledEvent exists */
    allowScheduleEvent() {
      return !!this.curScheduledEvent
    },
    /** Returns the availability as an array */
    availabilityArray() {
      return [...this.availability].map((item) => new Date(item))
    },
    allowDrag() {
      return (
        this.state === this.states.EDIT_AVAILABILITY ||
        this.state === this.states.SCHEDULE_EVENT
      )
    },
    /** Returns an array of calendar events for all of the authUser's enabled calendars, separated by the day they occur on */
    calendarEventsByDay() {
      // If this is an example calendar
      if (this.sampleCalendarEventsByDay) return this.sampleCalendarEventsByDay

      // If the user isn't logged in
      if (!this.authUser) return []

      let events = []
      let event

      const calendarAccounts = this.isGroup
        ? this.sharedCalendarAccounts
        : this.authUser.calendarAccounts

      // Adds events from calendar accounts that are enabled
      for (const id in calendarAccounts) {
        if (!calendarAccounts[id].enabled) continue

        if (this.calendarEventsMap.hasOwnProperty(id)) {
          for (const index in this.calendarEventsMap[id].calendarEvents) {
            event = this.calendarEventsMap[id].calendarEvents[index]

            // Check if we need to update authUser (to get latest subcalendars)
            const subCalendars = calendarAccounts[id].subCalendars
            if (!subCalendars || !(event.calendarId in subCalendars)) {
              // authUser doesn't contain the subCalendar, so push event to events without checking if subcalendar is enabled
              // and queue the authUser to be refreshed
              events.push(event)
              if (!this.hasRefreshedAuthUser && !this.isGroup) {
                this.refreshAuthUser()
              }
              continue
            }

            // Push event to events if subcalendar is enabled
            if (subCalendars[event.calendarId].enabled) {
              events.push(event)
            }
          }
        }
      }

      const eventsCopy = JSON.parse(JSON.stringify(events))

      const calendarEventsByDay = splitCalendarEventsByDay(
        this.event,
        eventsCopy,
        this.weekOffset
      )

      return calendarEventsByDay
    },
    /** [SPECIFIC TO GROUPS] Returns an object mapping user ids to their calendar events separated by the day they occur on */
    groupCalendarEventsByDay() {
      if (this.event.type !== eventTypes.GROUP) return {}

      const userIdToEventsByDay = {}
      for (const userId in this.event.responses) {
        if (userId === this.authUser._id) {
          userIdToEventsByDay[userId] = this.calendarEventsByDay
        } else if (userId in this.calendarAvailabilities) {
          userIdToEventsByDay[userId] = splitCalendarEventsByDay(
            this.event,
            this.calendarAvailabilities[userId],
            this.weekOffset
          )
        }
      }

      return userIdToEventsByDay
    },
    curRespondentsSet() {
      return new Set(this.curRespondents)
    },
    /** Returns the max number of people in the curRespondents array available at any given time */
    curRespondentsMax() {
      let max = 0
      for (const day of this.allDays) {
        for (const time of this.times) {
          const num = [
            ...this.getRespondentsForHoursOffset(
              day.dateObject,
              time.hoursOffset
            ),
          ].filter((r) => this.curRespondentsSet.has(r)).length

          if (num > max) max = num
        }
      }
      return max
    },
    /** Returns the day offset caused by the timezone offset. If the timezone offset changes the date, dayOffset != 0 */
    dayOffset() {
      return Math.floor((this.event.startTime - this.timezoneOffset / 60) / 24)
    },
    /** Returns all the days that are encompassed by startDate and endDate */
    allDays() {
      const days = []
      const daysOfWeek = ["sun", "mon", "tue", "wed", "thu", "fri", "sat"]
      const months = [
        "jan",
        "feb",
        "mar",
        "apr",
        "may",
        "jun",
        "jul",
        "aug",
        "sep",
        "oct",
        "nov",
        "dec",
      ]

      for (let i = 0; i < this.event.dates.length; ++i) {
        const date = new Date(this.event.dates[i])
        const offsetDate = new Date(date)
        offsetDate.setDate(offsetDate.getDate() + this.dayOffset)

        let dateString = ""
        if (this.isSpecificDates) {
          dateString = `${
            months[offsetDate.getUTCMonth()]
          } ${offsetDate.getUTCDate()}`
        } else if (this.isGroup) {
          const tmpDate = dateToDowDate(
            this.event.dates,
            offsetDate,
            this.weekOffset,
            true
          )

          dateString = `${
            months[tmpDate.getUTCMonth()]
          } ${tmpDate.getUTCDate()}`
        }

        days.push({
          dayText: daysOfWeek[offsetDate.getUTCDay()],
          dateString,
          dateObject: date,
        })
      }

      return days
    },
    /** Returns a subset of all days based on the page number */
    days() {
      return this.allDays.slice(
        this.page * this.maxDaysPerPage,
        Math.min(this.event.dates.length, (this.page + 1) * this.maxDaysPerPage)
      )
    },
    defaultState() {
      // Either the heatmap or the best_times state, depending on the toggle
      return this.showBestTimes ? this.states.BEST_TIMES : this.states.HEATMAP
    },
    editing() {
      // Returns whether currently in the editing state
      return this.state === this.states.EDIT_AVAILABILITY
    },
    scheduling() {
      // Returns whether currently in the scheduling state
      return this.state === this.states.SCHEDULE_EVENT
    },
    hintText() {
      switch (this.state) {
        case this.isGroup && this.states.EDIT_AVAILABILITY:
          return "Toggle which calendars are used. Editing availability is disabled and determined from your calendar events each week."
        case this.states.EDIT_AVAILABILITY:
          return "Click and drag to add your available times in green"
        case this.states.SCHEDULE_EVENT:
          return "Click and drag on the calendar to schedule a Google Calendar event during those times"
        default:
          return ""
      }
    },
    isPhone() {
      return isPhone(this.$vuetify)
    },
    isOwner() {
      return this.authUser?._id === this.event.ownerId
    },
    isSpecificDates() {
      return this.event.type === eventTypes.SPECIFIC_DATES || !this.event.type
    },
    isWeekly() {
      return this.event.type === eventTypes.DOW
    },
    isGroup() {
      return this.event.type === eventTypes.GROUP
    },
    respondents() {
      return Object.values(this.parsedResponses).map((r) => r.user)
    },
    selectedGuestRespondent() {
      if (this.curRespondents.length !== 1) return ""

      const user = this.parsedResponses[this.curRespondents[0]].user
      return this.isGuest(user) ? user._id : ""
    },
    scheduledEventStyle() {
      const style = {}
      let top, height
      if (this.dragging) {
        top = this.dragStart.timeIndex
        height = this.dragCur.timeIndex - this.dragStart.timeIndex + 1
      } else {
        top = this.curScheduledEvent.hoursOffset * 4
        height = this.curScheduledEvent.hoursLength * 4
      }
      style.top = `calc(${top} * 1rem)`
      style.height = `calc(${height} * 1rem)`
      return style
    },
    /** Parses the responses to the Schej, makes necessary changes based on the type of event, and returns it */
    parsedResponses() {
      const parsed = {}

      // Return calendar availability if group
      if (this.event.type === eventTypes.GROUP) {
        for (const userId in this.event.responses) {
          const calendarEventsByDay = this.groupCalendarEventsByDay[userId]
          if (calendarEventsByDay) {
            // Get manual availability and convert to DOW dates
            const fetchedManualAvailability = this.getManualAvailabilityDow(
              this.fetchedResponses[userId]?.manualAvailability
            )
            const curManualAvailability =
              userId === this.authUser._id
                ? this.getManualAvailabilityDow(this.manualAvailability)
                : {}

            // Get availability from calendar events and use manual availability on the
            // "touched" days
            const availability = this.getAvailabilityFromCalendarEvents(
              calendarEventsByDay,
              {
                includeTouchedAvailability: true,
                fetchedManualAvailability: fetchedManualAvailability ?? {},
                curManualAvailability: curManualAvailability ?? {},
              }
            )

            parsed[userId] = {
              ...this.event.responses[userId],
              availability: [...availability],
            }
          } else {
            parsed[userId] = {
              ...this.event.responses[userId],
              availability: [],
            }
          }
        }
        return parsed
      }

      // Otherwise, parse responses so that if _id is null (i.e. guest user), then it is set to the guest user's name
      for (const k of Object.keys(this.event.responses)) {
        const newUser = {
          ...this.event.responses[k].user,
          _id: k,
        }
        parsed[k] = {
          ...this.event.responses[k],
          availability: this.fetchedResponses[k]?.availability ?? [],
          user: newUser,
        }
      }
      return parsed
    },
    max() {
      let max = 0
      for (const [dateTime, availability] of this.responsesFormatted) {
        if (availability.size > max) {
          max = availability.size
        }
      }

      return max
    },
    times() {
      /* Returns the times that are encompassed by startTime and endTime */
      const times = []

      for (let i = 0; i < this.event.duration; ++i) {
        const utcTimeNum = this.event.startTime + i
        const localTimeNum = utcTimeToLocalTime(utcTimeNum, this.timezoneOffset)

        times.push({
          hoursOffset: i,
          text: timeNumToTimeText(localTimeNum),
        })
        times.push({
          hoursOffset: i + 0.25,
        })
        times.push({
          hoursOffset: i + 0.5,
        })
        times.push({
          hoursOffset: i + 0.75,
        })
      }

      return times
    },
    timezoneOffset() {
      if (!("offset" in this.curTimezone)) {
        return new Date().getTimezoneOffset()
      }

      if (this.event.type === eventTypes.DOW) {
        return this.curTimezone.offset * -1
      }

      // Can't just get the offset directly from curTimezone because it doesn't account for dates in the future
      // when daylight savings might be in or out of effect, so instead, we get the timezone for the first date
      // of the event
      return (
        dayjs(this.event.dates[0]).tz(this.curTimezone.value).utcOffset() * -1 // Multiply by -1 because offset is flipped
      )
    },
    userHasResponded() {
      return this.authUser && this.authUser._id in this.parsedResponses
    },
    showLeftZigZag() {
      return this.calendarScrollLeft > 0
    },
    showRightZigZag() {
      return Math.ceil(this.calendarScrollLeft) < this.calendarMaxScroll
    },
    maxDaysPerPage() {
      return this.isPhone ? this.mobileNumDays : 7
    },
    hasNextPage() {
      return (
        this.event.dates.length - (this.page + 1) * this.maxDaysPerPage > 0 ||
        this.event.type === eventTypes.GROUP
      )
    },
    hasPrevPage() {
      return this.page > 0 || this.event.type === eventTypes.GROUP
    },
    numPages() {
      return Math.ceil(this.event.dates.length / this.maxDaysPerPage)
    },

    showStickyRespondents() {
      return (
        this.isPhone &&
        !this.scrolledToRespondents &&
        (this.curTimeslot.dayIndex !== -1 ||
          this.curRespondent.length > 0 ||
          this.curRespondents.length > 0)
      )
    },
    hintClosed() {
      return !this.hintState || localStorage[this.hintStateLocalStorageKey]
    },
    hintStateLocalStorageKey() {
      return `closedHintText${this.state}` + ("&isGroup" ? this.isGroup : "")
    },

    /** Whether to show spinner on top of availability grid */
    showLoader() {
      return (
        // Loading calendar events
        ((this.isGroup || this.alwaysShowCalendarEvents || this.editing) &&
          this.loadingCalendarEvents) ||
        // Loading responses
        this.loadingResponses.loading
      )
    },
  },
  methods: {
    ...mapMutations(["setAuthUser"]),
    ...mapActions(["showInfo", "showError"]),

    // -----------------------------------
    //#region Date
    // -----------------------------------

    /** Returns a date object from the dayindex and timeindex given */
    getDateFromDayTimeIndex(dayIndex, timeIndex) {
      return getDateHoursOffset(
        this.days[dayIndex].dateObject,
        this.times[timeIndex].hoursOffset
      )
    },

    /** Returns a date object from the dayindex and hoursoffset given */
    getDateFromDayHoursOffset(dayIndex, hoursOffset) {
      return getDateHoursOffset(this.days[dayIndex].dateObject, hoursOffset)
    },
    //#endregion

    // -----------------------------------
    //#region Respondent
    // -----------------------------------
    mouseOverRespondent(e, id) {
      if (this.curRespondents.length === 0) {
        if (this.state === this.defaultState) {
          this.state = this.states.SINGLE_AVAILABILITY
        }

        this.curRespondent = id
      }
    },
    mouseLeaveRespondent(e) {
      if (this.curRespondents.length === 0) {
        if (this.state === this.states.SINGLE_AVAILABILITY) {
          this.state = this.defaultState
        }

        this.curRespondent = ""
      }
    },
    clickRespondent(e, id) {
      this.state = this.states.SUBSET_AVAILABILITY
      this.curRespondent = ""

      if (this.curRespondentsSet.has(id)) {
        // Remove id
        this.curRespondents = this.curRespondents.filter((r) => r != id)

        // Go back to default state if all users deselected
        if (this.curRespondents.length === 0) {
          this.state = this.defaultState
        }
      } else {
        // Add id
        this.curRespondents.push(id)
      }

      e.stopPropagation()
    },
    deselectRespondents(e) {
      // Don't deselect respondents if toggled best times
      if (
        e.target?.previousElementSibling?.id === "show-best-times-toggle" ||
        e.target?.firstChild?.firstChild?.id === "show-best-times-toggle"
      )
        return

      if (this.state === this.states.SUBSET_AVAILABILITY) {
        this.state = this.defaultState
      }

      this.curRespondents = []
    },

    isGuest(user) {
      return user._id == user.firstName
    },
    //#endregion

    // -----------------------------------
    //#region Aggregate user availability
    // -----------------------------------

    /** Fetches responses from server */
    fetchResponses() {
      if (this.calendarOnly) {
        this.fetchedResponses = this.event.responses
        return
      }

      let timeMin, timeMax
      if (this.event.type === eventTypes.GROUP) {
        if (this.event.dates.length > 0) {
          // Fetch the date range for the current week
          timeMin = new Date(this.event.dates[0])
          timeMax = new Date(this.event.dates[this.event.dates.length - 1])
          timeMax.setDate(timeMax.getDate() + 1)

          // Convert dow dates to discrete dates
          timeMin = dateToDowDate(
            this.event.dates,
            timeMin,
            this.weekOffset,
            true
          )
          timeMax = dateToDowDate(
            this.event.dates,
            timeMax,
            this.weekOffset,
            true
          )
        }
      } else {
        if (this.allDays.length > 0) {
          // Fetch the entire time range of availabilities
          timeMin = new Date(this.allDays[0].dateObject)
          timeMax = new Date(this.allDays[this.allDays.length - 1].dateObject)
          timeMax.setDate(timeMax.getDate() + 1)
        }
      }

      if (!timeMin || !timeMax) return

      // Fetch responses between timeMin and timeMax
      const url = `/events/${
        this.event._id
      }/responses?timeMin=${timeMin.toISOString()}&timeMax=${timeMax.toISOString()}`
      get(url)
        .then((responses) => {
          this.fetchedResponses = responses
          this.getResponsesFormatted()
        })
        .catch((err) => {
          this.showError(
            "There was an error fetching availability! Please refresh the page."
          )
        })
    },
    /** Formats the responses in a map where date/time is mapped to the people that are available then */
    getResponsesFormatted() {
      const lastFetched = new Date().getTime()
      this.loadingResponses.loading = true
      this.loadingResponses.lastFetched = lastFetched

      this.$worker
        .run(
          (days, times, parsedResponses) => {
            const dateCompare = (date1, date2) => {
              date1 = new Date(date1)
              date2 = new Date(date2)
              return date1.getTime() - date2.getTime()
            }
            const splitTimeNum = (timeNum) => {
              const hours = Math.floor(timeNum)
              const minutes = Math.floor((timeNum - hours) * 60)
              return { hours, minutes }
            }
            const getDateHoursOffset = (date, hoursOffset) => {
              const { hours, minutes } = splitTimeNum(hoursOffset)
              const newDate = new Date(date)
              newDate.setHours(newDate.getHours() + hours)
              newDate.setMinutes(newDate.getMinutes() + minutes)
              return newDate
            }
            const formatted = new Map()
            for (const day of days) {
              for (const time of times) {
                const date = getDateHoursOffset(
                  day.dateObject,
                  time.hoursOffset
                )
                formatted.set(date.getTime(), new Set())
                for (const response of Object.values(parsedResponses)) {
                  const index = response.availability.findIndex(
                    (d) => dateCompare(d, date) === 0
                  )
                  if (index !== -1) {
                    formatted.get(date.getTime()).add(response.user._id)
                    response.availability.splice(index, 1)
                  }
                }
              }
            }
            return formatted
          },
          [this.allDays, this.times, this.parsedResponses]
        )
        .then((formatted) => {
          // Only set responses formatted for the latest request
          if (lastFetched >= this.loadingResponses.lastFetched) {
            this.responsesFormatted = formatted
          }
        })
        .finally(() => {
          if (this.loadingResponses.lastFetched === lastFetched) {
            this.loadingResponses.loading = false
          }
        })
    },
    /** Returns a set of respondents for the given date/time */
    getRespondentsForHoursOffset(date, hoursOffset) {
      const d = getDateHoursOffset(date, hoursOffset)
      return this.responsesFormatted.get(d.getTime()) ?? new Set()
    },
    showAvailability(d, t) {
      if (this.state === this.states.EDIT_AVAILABILITY && this.isPhone) {
        // Don't show currently selected timeslot when on phone and editing
        return
      }

      // Update current timeslot (the timeslot that has a dotted border around it)
      this.curTimeslot = { dayIndex: d, timeIndex: t }

      if (this.state === this.states.EDIT_AVAILABILITY || this.curRespondent) {
        // Don't show availability when editing or when respondent is selected
        return
      }

      // Update current timeslot availability to show who is available for the given timeslot
      const available = this.getRespondentsForHoursOffset(
        this.days[d].dateObject,
        this.times[t].hoursOffset
      )
      for (const respondent of this.respondents) {
        if (available.has(respondent._id)) {
          this.curTimeslotAvailability[respondent._id] = true
        } else {
          this.curTimeslotAvailability[respondent._id] = false
        }
      }
    },
    //#endregion

    // -----------------------------------
    //#region Current user availability
    // -----------------------------------
    async refreshAuthUser() {
      this.hasRefreshedAuthUser = true
      await get("/user/profile").then((authUser) => {
        this.setAuthUser(authUser)
      })
    },
    /** resets cur user availability to the response stored on the server */
    resetCurUserAvailability() {
      if (this.event.type === eventTypes.GROUP) {
        this.initSharedCalendarAccounts()
        this.manualAvailability = {}
      }

      this.availability = new Set()
      if (this.userHasResponded) {
        this.populateUserAvailability(this.authUser._id)
      }
    },
    /** Populates the availability set for the auth user from the responses object stored on the server */
    populateUserAvailability(id) {
      this.parsedResponses[id]?.availability?.forEach((item) =>
        this.availability.add(new Date(item).getTime())
      )
      this.$nextTick(() => (this.unsavedChanges = false))
    },
    /** Returns a set containing the available times based on the given calendar events object */
    getAvailabilityFromCalendarEvents(
      calendarEventsByDay,
      options = {
        includeTouchedAvailability: false, // Whether to include manual availability for touched days
        fetchedManualAvailability: {}, // Object mapping unix timestamp to array of manual availability (fetched from server)
        curManualAvailability: {}, // Manual availability with edits (takes precedence over fetchedManualAvailability)
      }
    ) {
      const availability = new Set()
      for (let i = 0; i < this.event.dates.length; ++i) {
        const date = new Date(this.event.dates[i])

        if (options.includeTouchedAvailability) {
          const endDate = getDateHoursOffset(date, this.event.duration)

          // Check if manual availability has been added for the current date
          let manualAvailabilityAdded = false

          for (const time in options.curManualAvailability) {
            if (date.getTime() <= time && time <= endDate.getTime()) {
              options.curManualAvailability[time].forEach((a) => {
                availability.add(new Date(a).getTime())
              })
              delete options.curManualAvailability[time]
              manualAvailabilityAdded = true
              break
            }
          }

          if (manualAvailabilityAdded) continue

          for (const time in options.fetchedManualAvailability) {
            if (date.getTime() <= time && time <= endDate.getTime()) {
              options.fetchedManualAvailability[time].forEach((a) => {
                availability.add(new Date(a).getTime())
              })
              delete options.fetchedManualAvailability[time]
              manualAvailabilityAdded = true
              break
            }
          }

          if (manualAvailabilityAdded) continue
        }

        for (const time of this.times) {
          // Check if there exists a calendar event that overlaps [time, time+0.5]
          let startDate = getDateHoursOffset(date, time.hoursOffset)
          const endDate = getDateHoursOffset(date, time.hoursOffset + 0.25)
          const index = calendarEventsByDay[i].findIndex((e) => {
            const notIntersect =
              dateCompare(endDate, e.startDate) <= 0 ||
              dateCompare(startDate, e.endDate) >= 0
            return !notIntersect && !e.free
          })
          if (index === -1) {
            availability.add(startDate.getTime())
          }
        }
      }
      return availability
    },
    /** Constructs the availability array using calendarEvents array */
    setAvailabilityAutomatically() {
      // This is not a computed property because we should be able to change it manually from what it automatically fills in
      this.availability = new Set()
      const tmpAvailability = this.getAvailabilityFromCalendarEvents(
        this.calendarEventsByDay
      )

      const pageStartDate = getDateDayOffset(
        new Date(this.event.dates[0]),
        this.page * this.maxDaysPerPage
      )
      const pageEndDate = getDateDayOffset(pageStartDate, this.maxDaysPerPage)
      this.animateAvailability(tmpAvailability, pageStartDate, pageEndDate)
    },
    /** Animate the filling out of availability using setTimeout, between startDate and endDate */
    animateAvailability(availability, startDate, endDate) {
      this.availabilityAnimEnabled = true
      this.availabilityAnimTimeouts = []

      let msPerGroup = 25
      let blocksPerGroup = 2
      if (
        (availability.size / blocksPerGroup) * msPerGroup >
        this.maxAnimTime
      ) {
        blocksPerGroup = (availability.size * msPerGroup) / this.maxAnimTime
      }
      let availabilityArray = [...availability]
      availabilityArray = availabilityArray.filter((a) =>
        isDateBetween(a, startDate, endDate)
      )

      for (let i = 0; i < availabilityArray.length / blocksPerGroup + 1; ++i) {
        const timeout = setTimeout(() => {
          for (const a of availabilityArray.slice(
            i * blocksPerGroup,
            i * blocksPerGroup + blocksPerGroup
          )) {
            this.availability.add(a)
          }
          this.availability = new Set(this.availability)
          if (i >= availabilityArray.length / blocksPerGroup) {
            // Make sure the entire availability has been added (will not be guaranteed when only animating a portion of availability)
            this.availability = new Set(availability)
            this.availabilityAnimTimeouts.push(
              setTimeout(() => {
                this.availabilityAnimEnabled = false

                if (this.showSnackbar) {
                  this.showInfo(
                    "Your availability has been set automatically using your Google Calendar!"
                  )
                }
                this.unsavedChanges = false
              }, 500)
            )
          }
        }, i * msPerGroup)

        this.availabilityAnimTimeouts.push(timeout)
      }
    },
    stopAvailabilityAnim() {
      for (const timeout of this.availabilityAnimTimeouts) {
        clearTimeout(timeout)
      }
      this.availabilityAnimEnabled = false
    },
    async submitAvailability(name = "") {
      let payload = {}

      let type = ""
      // If this is a group submit enabled calendars, otherwise submit availability
      if (this.isGroup) {
        type = "group availability and calendars"
        payload = generateEnabledCalendarsPayload(this.sharedCalendarAccounts)
        payload.manualAvailability = {}
        for (const day of Object.keys(this.manualAvailability)) {
          payload.manualAvailability[day] = [
            ...this.manualAvailability[day],
          ].map((a) => new Date(a))
        }
      } else {
        type = "availability"
        payload.availability = this.availabilityArray
        if (this.authUser) {
          payload.guest = false
        } else {
          payload.guest = true
          payload.name = name
        }
      }

      await post(`/events/${this.event._id}/response`, payload)

      // Update analytics
      if (this.authUser) {
        if (this.authUser._id in this.parsedResponses) {
          this.$posthog?.capture(`Edited ${type}`, {
            eventId: this.event._id,
          })
        } else {
          this.$posthog?.capture(`Added ${type}`, {
            eventId: this.event._id,
          })
        }
      } else {
        if (name in this.parsedResponses) {
          this.$posthog?.capture(`Edited ${type} as guest`, {
            eventId: this.event._id,
            name,
          })
        } else {
          this.$posthog?.capture(`Added ${type} as guest`, {
            eventId: this.event._id,
            name,
          })
        }
      }

      this.refreshEvent()
      this.unsavedChanges = false
    },
    async deleteAvailability(name = "") {
      const payload = {}
      if (this.authUser) {
        payload.guest = false
        payload.userId = this.authUser._id

        this.$posthog?.capture("Deleted availability", {
          eventId: this.event._id,
        })
      } else {
        payload.guest = true
        payload.name = name

        this.$posthog?.capture("Deleted availability as guest", {
          eventId: this.event._id,
          name,
        })
      }
      await _delete(`/events/${this.event._id}/response`, payload)
      this.availability = new Set()
      if (this.isGroup) this.$router.replace({ name: "home" })
      else this.refreshEvent()
    },
    //#endregion

    // -----------------------------------
    //#region Timeslot
    // -----------------------------------
    setTimeslotSize() {
      /* Gets the dimensions of each timeslot and assigns it to the timeslot variable */
      const timeslotEl = document.querySelector(".timeslot")
      if (timeslotEl) {
        ;({ width: this.timeslot.width, height: this.timeslot.height } =
          timeslotEl.getBoundingClientRect())
      }
    },
    timeslotClassStyle(day, time, d, t) {
      /* Returns a class string and style object for the given timeslot div */
      let c = ""
      const s = {}
      // Animation
      if (this.animateTimeslotAlways || this.availabilityAnimEnabled) {
        c += "animate-bg-color "
      }

      // Border style
      if (
        (this.respondents.length > 0 ||
          this.state === this.states.EDIT_AVAILABILITY) &&
        this.curTimeslot.dayIndex === d &&
        this.curTimeslot.timeIndex === t
      ) {
        // Dashed border for currently selected timeslot
        c += "tw-border tw-border-dashed tw-border-black tw-z-10 "
      } else {
        // Normal border
        const fractionalTime = time.hoursOffset - parseInt(time.hoursOffset)
        if (fractionalTime === 0.25) {
          c += "tw-border-b "
          s.borderBottomStyle = "dashed"
        } else if (fractionalTime === 0.75) {
          c += "tw-border-b "
        }

        if (d === 0) c += "tw-border-l tw-border-l-gray "
        if (d === this.days.length - 1) c += "tw-border-r-gray "
        if (t === 0) c += "tw-border-t tw-border-t-gray "
        if (t === this.times.length - 1) c += "tw-border-b-gray "
      }

      // Fill style
      if (this.state === this.states.EDIT_AVAILABILITY) {
        // Set default background color to red (unavailable)
        s.backgroundColor = "#E523230D"

        // Show only current user availability
        const inDragRange = this.inDragRange(d, t)
        if (inDragRange) {
          // Set style if drag range goes over the current timeslot
          if (this.dragType === this.DRAG_TYPES.ADD) {
            s.backgroundColor = "#00994C88"
          } else if (this.dragType === this.DRAG_TYPES.REMOVE) {
          }
        } else {
          // Otherwise just show the current availability
          // Show current availability from availability set
          const date = getDateHoursOffset(day.dateObject, time.hoursOffset)
          if (this.availability.has(date.getTime())) {
            s.backgroundColor = "#00994C88"
          }
        }
      }

      if (this.state === this.states.SINGLE_AVAILABILITY) {
        // Show only the currently selected respondent's availability
        const respondent = this.curRespondent
        const respondents = this.getRespondentsForHoursOffset(
          day.dateObject,
          time.hoursOffset
        )
        if (respondents.has(respondent)) {
          s.backgroundColor = "#00994C88"
        }
      }

      if (
        this.state === this.states.BEST_TIMES ||
        this.state === this.states.HEATMAP ||
        this.state === this.states.SCHEDULE_EVENT ||
        this.state === this.states.SUBSET_AVAILABILITY
      ) {
        let numRespondents
        let max

        if (
          this.state === this.states.BEST_TIMES ||
          this.state === this.states.HEATMAP ||
          this.state === this.states.SCHEDULE_EVENT
        ) {
          numRespondents = this.getRespondentsForHoursOffset(
            day.dateObject,
            time.hoursOffset
          ).size
          max = this.max
        } else if (this.state === this.states.SUBSET_AVAILABILITY) {
          numRespondents = [
            ...this.getRespondentsForHoursOffset(
              day.dateObject,
              time.hoursOffset
            ),
          ].filter((r) => this.curRespondentsSet.has(r)).length

          max = this.curRespondentsMax
        }

        const totalRespondents = this.respondents.length

        if (this.defaultState === this.states.BEST_TIMES) {
          if (max > 0 && numRespondents === max) {
            // Only set timeslot to green for the times that most people are available
            if (totalRespondents === 1) {
              // Make single responses less saturated
              const green = "#00994CAA"
              s.backgroundColor = green
            } else {
              const green = "#00994C"
              s.backgroundColor = green
            }
          }
        } else if (this.defaultState === this.states.HEATMAP) {
          if (numRespondents > 0) {
            if (totalRespondents === 1) {
              // Make single responses less saturated
              const green = "#00994CAA"
              s.backgroundColor = green
            } else {
              // Determine color of timeslot based on number of people available
              const frac = numRespondents / max
              const green = "#00994C"
              let alpha = (frac * (255 - 30))
                .toString(16)
                .toUpperCase()
                .substring(0, 2)
              if (frac == 1) alpha = "FF"

              s.backgroundColor = green + alpha
            }
          }
        }
      }

      return { class: c, style: s }
    },
    timeslotVon(d, t) {
      if (this.interactable) {
        return {
          click: () => this.showAvailability(d, t),
          mousedown: () => {
            if (
              this.state === this.defaultState &&
              (!this.isPhone || this.respondents.length == 0)
            )
              this.highlightAvailabilityBtn()
          },
          mouseover: () => this.showAvailability(d, t),
        }
      }
      return {}
    },
    resetCurTimeslot() {
      this.curTimeslotAvailability = {}
      for (const respondent of this.respondents) {
        this.curTimeslotAvailability[respondent._id] = true
      }
      this.curTimeslot = { dayIndex: -1, timeIndex: -1 }

      // End drag if mouse left time grid
      this.endDrag()
    },
    //#endregion

    // -----------------------------------
    //#region Editing
    // -----------------------------------
    startEditing() {
      this.state = this.states.EDIT_AVAILABILITY
      if (this.authUser) {
        this.resetCurUserAvailability()
      }
      this.pageHasChanged = false
    },
    stopEditing() {
      this.state = this.defaultState
      this.stopAvailabilityAnim()
    },
    highlightAvailabilityBtn() {
      this.$emit("highlightAvailabilityBtn")
    },
    editGuestAvailability(id) {
      this.populateUserAvailability(id)
      this.$emit("setCurGuestId", id)
      this.startEditing()
    },
    refreshEvent() {
      this.$emit("refreshEvent")
    },
    //#endregion

    // -----------------------------------
    //#region Schedule event
    // -----------------------------------
    scheduleEvent() {
      this.state = this.states.SCHEDULE_EVENT
    },
    cancelScheduleEvent() {
      this.state = this.defaultState
    },

    /** Redirect user to Google Calendar to finish the creation of the event */
    confirmScheduleEvent() {
      if (!this.curScheduledEvent) return
      // Get start date, and end date from the area that the user has dragged out
      const { dayIndex, hoursOffset, hoursLength } = this.curScheduledEvent
      let startDate = this.getDateFromDayHoursOffset(dayIndex, hoursOffset)
      let endDate = this.getDateFromDayHoursOffset(
        dayIndex,
        hoursOffset + hoursLength
      )

      if (this.isWeekly) {
        // Determine offset based on current day of the week.
        // People expect the event to be scheduled in the future, not the past, which is why this check exists
        let offset = 0
        if (new Date().getDay() > startDate.getDay()) {
          offset = 1
        }

        // Transform startDate and endDate to be the current week offset
        startDate = dateToDowDate(this.event.dates, startDate, offset, true)
        endDate = dateToDowDate(this.event.dates, endDate, offset, true)
      }

      // Format email string separated by commas
      const emails = this.respondents.map((r) => {
        // Return email if they are not a guest, otherwise return their name
        if (r.email.length > 0) {
          return r.email
        } else {
          return `${r.firstName} (no email)`
        }
      })
      const emailsString = encodeURIComponent(emails.join(","))

      // Format start and end date to be in the format required by gcal (remove -, :, and .000)
      const start = startDate.toISOString().replace(/([-:]|\.000)/g, "")
      const end = endDate.toISOString().replace(/([-:]|\.000)/g, "")

      // Construct Google Calendar event creation template url
      const url = `https://calendar.google.com/calendar/render?action=TEMPLATE&text=${encodeURIComponent(
        this.event.name
      )}&dates=${start}/${end}&details=${encodeURIComponent(
        "\n\nThis event was scheduled with schej: https://schej.it/e/"
      )}${this.event._id}&ctz=${this.curTimezone.value}&add=${emailsString}`

      // Navigate to url and reset state
      window.open(url, "_blank")
      this.state = this.defaultState
    },
    //#endregion

    // -----------------------------------
    //#region Drag Stuff
    // -----------------------------------
    normalizeXY(e) {
      /* Normalize the touch event to be relative to element */
      let pageX, pageY
      if ("touches" in e) {
        // is a touch event
        ;({ pageX, pageY } = e.touches[0])
      } else {
        // is a mouse event
        ;({ pageX, pageY } = e)
      }
      const { left, top } = e.currentTarget.getBoundingClientRect()
      const x = pageX - left
      const y = pageY - top - window.scrollY
      return { x, y }
    },
    getDateFromXY(x, y) {
      /* Returns a date for the timeslot we are currently hovering over given the x and y position */
      const { width, height } = this.timeslot
      let dayIndex = Math.floor(x / width)
      let timeIndex = Math.floor(y / height)
      dayIndex = clamp(dayIndex, 0, this.days.length - 1)
      timeIndex = clamp(timeIndex, 0, this.times.length - 1)
      return {
        dayIndex,
        timeIndex,
        date: getDateHoursOffset(
          this.days[dayIndex].dateObject,
          this.times[timeIndex].hoursOffset
        ),
      }
    },
    endDrag() {
      if (!this.allowDrag) return

      if (!this.dragStart || !this.dragCur) return

      if (this.state === this.states.EDIT_AVAILABILITY) {
        // Update availability set based on drag region
        let dayInc =
          (this.dragCur.dayIndex - this.dragStart.dayIndex) /
          Math.abs(this.dragCur.dayIndex - this.dragStart.dayIndex)
        let timeInc =
          (this.dragCur.timeIndex - this.dragStart.timeIndex) /
          Math.abs(this.dragCur.timeIndex - this.dragStart.timeIndex)
        if (isNaN(dayInc)) dayInc = 1
        if (isNaN(timeInc)) timeInc = 1
        let d = this.dragStart.dayIndex
        while (d != this.dragCur.dayIndex + dayInc) {
          let t = this.dragStart.timeIndex
          while (t != this.dragCur.timeIndex + timeInc) {
            const date = getDateHoursOffset(
              this.days[d].dateObject,
              this.times[t].hoursOffset
            )

            // Add / remove time from availability set
            if (this.dragType === this.DRAG_TYPES.ADD) {
              this.availability.add(date.getTime())
            } else if (this.dragType === this.DRAG_TYPES.REMOVE) {
              this.availability.delete(date.getTime())
            }

            // Edit manualAvailability set if event is a GROUP
            if (this.event.type === eventTypes.GROUP) {
              const discreteDate = dateToDowDate(
                this.event.dates,
                date,
                this.weekOffset,
                true
              )
              const startDateOfDay = dateToDowDate(
                this.event.dates,
                this.days[d].dateObject,
                this.weekOffset,
                true
              )

              // If date not touched, then add all of the existing calendar availabilities and mark it as touched
              if (!(startDateOfDay.getTime() in this.manualAvailability)) {
                // Create new set
                this.manualAvailability[startDateOfDay.getTime()] = new Set()

                // Add the existing calendar availabilities
                const existingAvailability = this.getAvailabilityForDate(
                  this.days[d].dateObject
                )
                for (const a of existingAvailability) {
                  const convertedDate = dateToDowDate(
                    this.event.dates,
                    new Date(a),
                    this.weekOffset,
                    true
                  )
                  this.manualAvailability[startDateOfDay.getTime()].add(
                    convertedDate.getTime()
                  )
                }
              }

              // Add / remove time from manual availability set
              if (this.dragType === this.DRAG_TYPES.ADD) {
                this.manualAvailability[startDateOfDay.getTime()].add(
                  discreteDate.getTime()
                )
              } else if (this.dragType === this.DRAG_TYPES.REMOVE) {
                this.manualAvailability[startDateOfDay.getTime()].delete(
                  discreteDate.getTime()
                )
              }
            }

            t += timeInc
          }
          d += dayInc
        }
        this.availability = new Set(this.availability)
      } else if (this.state === this.states.SCHEDULE_EVENT) {
        // Update scheduled event
        const dayIndex = this.dragStart.dayIndex
        const hoursOffset = this.dragStart.timeIndex / 4
        const hoursLength =
          (this.dragCur.timeIndex - this.dragStart.timeIndex + 1) / 4

        if (hoursLength > 0) {
          this.curScheduledEvent = { dayIndex, hoursOffset, hoursLength }
        } else {
          this.curScheduledEvent = null
        }
      }

      // Set dragging defaults
      this.dragging = false
      this.dragStart = null
      this.dragCur = null
    },
    inDragRange(dayIndex, timeIndex) {
      /* Returns whether the given day and time index is within the drag range */
      if (this.dragging) {
        return (
          (isBetween(
            dayIndex,
            this.dragStart.dayIndex,
            this.dragCur.dayIndex
          ) ||
            isBetween(
              dayIndex,
              this.dragCur.dayIndex,
              this.dragStart.dayIndex
            )) &&
          (isBetween(
            timeIndex,
            this.dragStart.timeIndex,
            this.dragCur.timeIndex
          ) ||
            isBetween(
              timeIndex,
              this.dragCur.timeIndex,
              this.dragStart.timeIndex
            ))
        )
      }
    },
    moveDrag(e) {
      if (!this.allowDrag) return
      if (e.touches?.length > 1) return // If dragging with more than one finger

      e.preventDefault()
      const { dayIndex, timeIndex, date } = this.getDateFromXY(
        ...Object.values(this.normalizeXY(e))
      )
      this.dragCur = { dayIndex, timeIndex }
    },
    startDrag(e) {
      if (!this.allowDrag) return
      if (e.touches?.length > 1) return // If dragging with more than one finger

      e.preventDefault()

      this.dragging = true

      const { dayIndex, timeIndex, date } = this.getDateFromXY(
        ...Object.values(this.normalizeXY(e))
      )
      this.dragStart = { dayIndex, timeIndex }
      this.dragCur = { dayIndex, timeIndex }
      // Set drag type
      if (this.availability.has(date.getTime())) {
        this.dragType = this.DRAG_TYPES.REMOVE
      } else {
        this.dragType = this.DRAG_TYPES.ADD
      }
    },
    //#endregion

    // -----------------------------------
    //#region Options
    // -----------------------------------
    getLocalTimezone() {
      const split = new Date(this.event.dates[0])
        .toLocaleTimeString("en-us", { timeZoneName: "short" })
        .split(" ")
      const localTimezone = split[split.length - 1]

      return localTimezone
    },
    onShowBestTimesChange() {
      localStorage["showBestTimes"] = this.showBestTimes
      if (
        this.state == this.states.BEST_TIMES ||
        this.state == this.states.HEATMAP
      )
        this.state = this.defaultState
    },
    //#endregion

    // -----------------------------------
    //#region Scroll
    // -----------------------------------
    onCalendarScroll(e) {
      this.calendarMaxScroll = e.target.scrollWidth - e.target.offsetWidth
      this.calendarScrollLeft = e.target.scrollLeft
    },
    onScroll(e) {
      const afterEl = this.$refs.afterRespondentsList
      const beforeEl = this.$refs.beforeRespondentsList
      if (afterEl && beforeEl) {
        const { bottom: beforeBottom } = beforeEl.getBoundingClientRect()
        const { bottom: afterBottom } = afterEl.getBoundingClientRect()
        // 64 is height of bottom bar, 100 is max height of sticky respondents section
        this.scrolledToRespondents =
          beforeBottom + 100 + 64 < window.innerHeight ||
          afterBottom + 64 < window.innerHeight
      }
    },
    //#endregion

    // -----------------------------------
    //#region Pagination
    // -----------------------------------
    nextPage(e) {
      e.stopImmediatePropagation()
      if (this.event.type === eventTypes.GROUP) {
        // Go to next page if there are still more days left to see
        // Otherwise, update week offset
        if ((this.page + 1) * this.maxDaysPerPage < this.event.dates.length) {
          this.page++
        } else {
          this.page = 0
          this.$emit("update:weekOffset", this.weekOffset + 1)
        }
      } else {
        this.page++
      }
      this.pageHasChanged = true
    },
    prevPage(e) {
      e.stopImmediatePropagation()
      if (this.event.type === eventTypes.GROUP) {
        // Go to prev page if there is a prev page
        // Otherwise, update week offset
        if (this.page > 0) {
          this.page--
        } else {
          this.page =
            Math.ceil(this.event.dates.length / this.maxDaysPerPage) - 1
          this.$emit("update:weekOffset", this.weekOffset - 1)
        }
      } else {
        this.page--
      }
      this.pageHasChanged = true
    },
    //#endregion

    // -----------------------------------
    //#region Resize
    // -----------------------------------
    onResize() {
      this.setTimeslotSize()
    },
    //#endregion

    // -----------------------------------
    //#region hint
    // -----------------------------------
    closeHint() {
      this.hintState = false
      localStorage[this.hintStateLocalStorageKey] = true
    },
    //#endregion

    // -----------------------------------
    //#region Group
    // -----------------------------------

    /** Toggles calendar account - in groups to enable/disable calendars */
    toggleCalendarAccount(payload) {
      this.sharedCalendarAccounts[payload.email].enabled = payload.enabled
      this.sharedCalendarAccounts = JSON.parse(
        JSON.stringify(this.sharedCalendarAccounts)
      )
    },

    /** Toggles sub calendar account - in groups to enable/disable sub calendars */
    toggleSubCalendarAccount(payload) {
      this.sharedCalendarAccounts[payload.email].subCalendars[
        payload.subCalendarId
      ].enabled = payload.enabled
      this.sharedCalendarAccounts = JSON.parse(
        JSON.stringify(this.sharedCalendarAccounts)
      )
    },

    /** Sets the initial sharedCalendarAccounts object */
    initSharedCalendarAccounts() {
      if (!this.authUser) return

      // Init shared calendar accounts to current calendar accounts
      this.sharedCalendarAccounts = JSON.parse(
        JSON.stringify(this.authUser.calendarAccounts)
      )

      // Disable all calendars
      for (const id in this.sharedCalendarAccounts) {
        this.sharedCalendarAccounts[id].enabled = false
        if (this.sharedCalendarAccounts[id].subCalendars) {
          for (const subCalendarId in this.sharedCalendarAccounts[id]
            .subCalendars) {
            this.sharedCalendarAccounts[id].subCalendars[
              subCalendarId
            ].enabled = false
          }
        }
      }

      // Enable calendars based on responses
      if (this.authUser._id in this.event.responses) {
        const enabledCalendars =
          this.event.responses[this.authUser._id].enabledCalendars

        for (const id in enabledCalendars) {
          this.sharedCalendarAccounts[id].enabled = true

          enabledCalendars[id].forEach((subCalendarId) => {
            this.sharedCalendarAccounts[id].subCalendars[
              subCalendarId
            ].enabled = true
          })
        }
      }
    },

    /** Based on the date, determine whether it has been touched */
    isTouched(date, availability = [...this.availability]) {
      const start = new Date(date)
      const end = new Date(date)
      end.setHours(end.getHours() + this.event.duration)

      for (const a of availability) {
        const availableTime = new Date(a).getTime()
        if (
          start.getTime() <= availableTime &&
          availableTime <= end.getTime()
        ) {
          return true
        }
      }

      return false
    },

    /** Returns a subset of availability for the current date */
    getAvailabilityForDate(date, availability = [...this.availability]) {
      const start = new Date(date)
      const end = new Date(date)
      end.setHours(end.getHours() + this.event.duration)

      const subset = new Set()
      for (const a of availability) {
        const availableTime = new Date(a).getTime()
        if (
          start.getTime() <= availableTime &&
          availableTime <= end.getTime()
        ) {
          subset.add(availableTime)
        }
      }

      return subset
    },

    /** Returns a copy of the manual availability, converted to dow dates */
    getManualAvailabilityDow(manualAvailability = this.manualAvailability) {
      if (!manualAvailability) return null

      const manualAvailabilityDow = {}
      for (const time in manualAvailability) {
        const dowTime = dateToDowDate(
          this.event.dates,
          new Date(parseInt(time)),
          this.weekOffset
        ).getTime()
        manualAvailabilityDow[dowTime] = [...manualAvailability[time]].map(
          (a) => dateToDowDate(this.event.dates, new Date(a), this.weekOffset)
        )
      }
      return manualAvailabilityDow
    },

    //#endregion
  },
  watch: {
    availability() {
      if (this.state === this.states.EDIT_AVAILABILITY) {
        this.unsavedChanges = true
      }
    },
    event: {
      immediate: true,
      handler() {
        this.initSharedCalendarAccounts()
        this.fetchResponses()
      },
    },
    state(nextState, prevState) {
      // Reset scheduled event when exiting schedule event state
      if (prevState === this.states.SCHEDULE_EVENT) {
        this.curScheduledEvent = null
      } else if (prevState === this.states.EDIT_AVAILABILITY) {
        this.unsavedChanges = false
      }
    },
    respondents: {
      immediate: true,
      handler() {
        this.curTimeslotAvailability = {}
        for (const respondent of this.respondents) {
          this.curTimeslotAvailability[respondent._id] = true
        }
      },
    },
    calendarEventsByDay() {
      if (
        this.state === this.states.EDIT_AVAILABILITY &&
        this.authUser &&
        !(this.authUser?._id in this.event.responses) && // User hasn't responded yet
        !this.loadingCalendarEvents &&
        (!this.unsavedChanges || this.availabilityAnimEnabled)
      ) {
        for (const timeout of this.availabilityAnimTimeouts) {
          clearTimeout(timeout)
        }
        this.setAvailabilityAutomatically()
      }
    },
    page() {
      this.$nextTick(() => {
        this.setTimeslotSize()
      })
    },
    showStickyRespondents: {
      immediate: true,
      handler(cur) {
        clearTimeout(this.delayedShowStickyRespondentsTimeout)
        this.delayedShowStickyRespondentsTimeout = setTimeout(() => {
          this.delayedShowStickyRespondents = cur
        }, 100)
      },
    },
    maxDaysPerPage() {
      // Set page to 0 if user switches from portrait to landscape orientation and we're on an invalid page number,
      // i.e. we're on a page that displays 0 days
      if (this.page * this.maxDaysPerPage >= this.event.dates.length) {
        this.page = 0
      }
    },
    mobileNumDays() {
      // Save mobile num days in localstorage
      localStorage["mobileNumDays"] = this.mobileNumDays

      // Set timeslot size because it has changed
      this.$nextTick(() => {
        this.setTimeslotSize()
      })
    },
    weekOffset() {
      if (this.event.type === eventTypes.GROUP) {
        this.fetchResponses()
      }
    },
    parsedResponses() {
      // Theoretically, parsed responses should only be changing for groups
      this.getResponsesFormatted()

      // Repopulate user availability when editing availability (this happens when switching weeks in a group)
      if (
        this.event.type === eventTypes.GROUP &&
        this.state === this.states.EDIT_AVAILABILITY &&
        this.authUser
      ) {
        this.availability = new Set()
        this.populateUserAvailability(this.authUser._id)
      }
    },
  },
  created() {
    this.resetCurUserAvailability()

    addEventListener("click", this.deselectRespondents)
  },
  mounted() {
    // Set initial state to best_times or heatmap depending on show best times toggle.
    this.state = this.showBestTimes ? "best_times" : "heatmap"

    // Set initial calendar max scroll
    this.calendarMaxScroll =
      this.$refs.calendar.scrollWidth - this.$refs.calendar.offsetWidth

    // Get timeslot size
    this.setTimeslotSize()
    addEventListener("resize", this.onResize)
    addEventListener("scroll", this.onScroll)
    if (!this.calendarOnly) {
      const timesEl = document.getElementById("times")
      if (isTouchEnabled()) {
        timesEl.addEventListener("touchstart", this.startDrag)
        timesEl.addEventListener("touchmove", this.moveDrag)
        timesEl.addEventListener("touchend", this.endDrag)
        timesEl.addEventListener("touchcancel", this.endDrag)
      }
      timesEl.addEventListener("mousedown", this.startDrag)
      timesEl.addEventListener("mousemove", this.moveDrag)
      timesEl.addEventListener("mouseup", this.endDrag)
    }
  },
  beforeDestroy() {
    removeEventListener("click", this.deselectRespondents)
    removeEventListener("resize", this.onResize)
    removeEventListener("scroll", this.onScroll)
  },
  components: {
    UserAvatarContent,
    ZigZag,
    ConfirmDetailsDialog,
    ToolRow,
    CalendarAccounts,
    RespondentsList,
  },
}
</script>
